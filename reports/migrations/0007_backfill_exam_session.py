# # Generated by Django 5.2.4 on 2025-08-18 19:45

# from django.db import migrations


# class Migration(migrations.Migration):

#     dependencies = [
#         ('reports', '0006_examsession_exam_session_studentsession'),
#     ]

#     operations = [
#     ]
# reports/migrations/00xx_backfill_exam_session.py
from django.db import migrations

def backfill_exam_session(apps, schema_editor):
    Exam = apps.get_model('reports', 'Exam')
    ExamSession = apps.get_model('reports', 'ExamSession')

    # Use or create a baseline session to attach legacy exams
    default_session, _ = ExamSession.objects.get_or_create(
        code='2025-26',  # keep a code field; see model below
        defaults={'name': 'Session 2025â€“2026', 'start_date':'2025-08-01', 'end_date':'2026-07-31'}
    )

    # If you have an exam.date field, you could map by date range instead of a hard default.
    # For now (no assumptions), attach all legacy rows to default_session.
    Exam.objects.filter(session__isnull=True).update(session=default_session)

def reverse_func(apps, schema_editor):
    # No-op
    pass

class Migration(migrations.Migration):
    dependencies = [
        ('reports', '0006_examsession_exam_session_studentsession'),
    ]
    operations = [
        migrations.RunPython(backfill_exam_session, reverse_func),
    ]
